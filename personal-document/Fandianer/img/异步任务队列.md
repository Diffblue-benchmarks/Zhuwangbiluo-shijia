1Optimus-AsyncTask 架构文档
======================

[](https://souche.yuque.com/arch/optask/kgwl91#c931653c)场景
----------------------------------------------------------

*   普通异步任务：适用于将长耗时任务异步化。（eg: 影像件服务生成pdf）
*   延时回调任务：适用于需要定时回调的任务。（eg: 交易场景定时关单）
*   执行依赖任务：适用于互相之间有依赖关系的任务。（eg：支付平台处理有依赖关系的回调）

[](https://souche.yuque.com/arch/optask/kgwl91#6433b698)整体架构
------------------------------------------------------------

### [](https://souche.yuque.com/arch/optask/kgwl91#7cc9f6e9)设计原则

*   应用只消费自己的消息。（与MQ产品不同）
*   业务隔离，独立部署。（应用之间无公共依赖）
*   高性能，高并发。（Redis 缓存实现）
*   开发友好：简化开发运维流程。（无需事先注册 Topic）

### [](https://souche.yuque.com/arch/optask/kgwl91#65aa05f0)架构图

 ![](./Optimus-AsyncTask 架构文档 · 杭州大搜车汽车服务有限公司_files/1547190786242-63c93470-0724-4594-90e0-1aa68998d167.png) 

### [](https://souche.yuque.com/arch/optask/kgwl91#44e22ce7)任务状态机

 ![](./Optimus-AsyncTask 架构文档 · 杭州大搜车汽车服务有限公司_files/1546589238492-433dbc20-7e07-4a6f-ad75-37daeae5aa9d.png) 

  

  

  

### [](https://souche.yuque.com/arch/optask/kgwl91#51ae9800)时序图

![](./Optimus-AsyncTask 架构文档 · 杭州大搜车汽车服务有限公司_files/e62dc48ed68991c91123a8e1b976a864.svg)

  

[](https://souche.yuque.com/arch/optask/kgwl91#05022037)编程模型
------------------------------------------------------------

  

### [](https://souche.yuque.com/arch/optask/kgwl91#f9928eef)声明Task

  

#### [](https://souche.yuque.com/arch/optask/kgwl91#5611af67)普通的异步任务

package com.souche.async.examples;

import com.souche.async.client.OpAsyncTask;
import com.souche.async.client.BaseAsyncTaskHandler;

import java.util.Map;

@OpAsyncTask(timeout = 600, maxRetry = 3)
public class DemoAsyncTaskHandler implements BaseAsyncTaskHandler {

    @Override
    public void performAsync(Map<String, Object> params) {
        //do something
    }

    /**
     \* 业务方需要实现这个回调方法，根据自己传给perform方法的params参数，返回一个bizId,
     \* 以实现业务除重: 对于一个taskHandler, 多次提交bizId相同的任务, 框架只会执行一次.
     *
     \* @param params 调用方传给perform方法的参数
     \* @return
     */
    @Override
    public String getBizId(Map<String, Object> params) {
        return params.get("k1") + "-" + params.get("k2");
    }

    /**
     \* 处理任务死亡逻辑
     *
     \* @param params 调用方传给perform方法的参数
     \* @return
     */
    @Override
    public void onDead(Map<String, Object> params) {
        //do something
    }
}

  

#### [](https://souche.yuque.com/arch/optask/kgwl91#dad0970b)延时任务

package com.souche.async.examples;

import com.souche.async.client.BaseDelayTaskHandler;
import com.souche.async.client.OpAsyncTask;

import java.util.Map;

@OpAsyncTask(timeout = 600, maxRetry = 3)
public class DemoDelayTaskHandler implements BaseDelayTaskHandler {

    /**
     \* @param params     任务参数
     \* @param delayedSec 延时多久之后执行
     */
    @Override
    public void performDelay(Map<String, Object> params, int delayedSec) {
        //do something
    }

    /**
     \* 业务方需要实现这个回调方法，根据自己传给perform方法的params参数，返回一个bizId,
     \* 以实现业务除重: 对于一个taskHandler, 多次提交bizId相同的任务, 框架只会执行一次.
     *
     \* @param params 调用方传给perform方法的参数
     \* @return
     */
    @Override
    public String getBizId(Map<String, Object> params) {
        return params.get("k1") + "-" + params.get("k2");
    }

    /**
     \* 处理任务死亡逻辑
     *
     \* @param params 调用方传给perform方法的参数
     \* @return
     */
    @Override
    public void onDead(Map<String, Object> params) {
        //do something
    }
}

  

#### [](https://souche.yuque.com/arch/optask/kgwl91#5290894d)依赖任务

package com.souche.async.examples;

import com.souche.async.client.BaseDependTaskHandler;
import com.souche.async.client.OpAsyncTask;

import java.util.Map;

@OpAsyncTask(timeout = 600, maxRetry = 3,
        //依赖任务, 等待父任务完成的最大等待时间
        maxWaitTime = 1800)
public class DemoDependTaskHandler implements BaseDependTaskHandler {

    /**
     \* @param params         任务参数
     \* @param dependSelfId   依赖任务的自身ID, 没有子任务时可以不填
     \* @param dependParentId 依赖任务的父ID, 没有父任务时可以不填
     */
    @Override
    public void performDepend(Map<String, Object> params, String dependSelfId, String dependParentId) {
        //do something
    }

    @Override
    public String getBizId(Map<String, Object> params) {
        return params.get("k1") + "-" + params.get("k2");
    }

    @Override
    public void onDead(Map<String, Object> params) {
        //do something
    }

    /**
     \* 处理等待父任务完成时发生等待超时 (仅在depend模式下有效)
     *
     \* @param params 调用方传给perform方法的参数
     */
    @Override
    public void onTimeoutForWaitParent(Map<String, Object> params) {
        //do something
    }
}

### [](https://souche.yuque.com/arch/optask/kgwl91#39583436)调用Task

  

package com.souche.async.examples;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
public class DemoService {

    @Autowired
    private DemoAsyncTaskHandler asyncTaskHandler;

    @Autowired
    private DemoDelayTaskHandler delayTaskHandler;

    @Autowired
    private DemoDependTaskHandler1 dependTaskHandler1;

    @Autowired
    private DemoDependTaskHandler2 dependTaskHandler2;

    @Autowired
    private DemoDependTaskHandler3 dependTaskHandler3;

    public void invokeAsync() {
        Map<String, Object> params = new HashMap<>();
        params.put("k1", "v1");
        params.put("k2", "v2");
        asyncTaskHandler.performAsync(params);
    }

    public void invokeDelay() {
        Map<String, Object> params = new HashMap<>();
        params.put("k1", "v1");
        params.put("k2", "v2");
        // 1800秒之后执行
        delayTaskHandler.performDelay(params, 1800);
    }

    public void invokeDepend() {
        Map<String, Object> params = new HashMap<>();
        params.put("k1", "v1");
        params.put("k2", "v2");

        // 下面以任务3依赖任务2，任务2又依赖任务1(3 -> 2 -> 1)为例:

        // 因为没有其他任务依赖自己, dependSelfId 可以不填; dependParentId 为 2
        dependTaskHandler3.performDepend(params, null, "2");
        // dependSelfId 为 2: dependParentId 为 1 
        dependTaskHandler2.performDepend(params, "2", "1");
        // dependSelfId 为 1; 因为没有父任务，dependParentId 可以不填
        dependTaskHandler1.performDepend(params, "1", null);
    }
}

  

### [](https://souche.yuque.com/arch/optask/kgwl91#b6453aea)基础配置

package com.souche.async.examples;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AsyncTaskConfig {

    @Bean
    public AsyncTask asyncTask() {
        return new AsyncTask();
    }
}

  

opat.redisAddress=xxx
opat.dashboardAddress=xxx
opat.workerThreadNum=10

  

  

[](https://souche.yuque.com/arch/optask/kgwl91#6d820a95)关键技术点
-------------------------------------------------------------

### [](https://souche.yuque.com/arch/optask/kgwl91#a466788a)异步任务注册

任务注册概念比较弱，系统以任务处理类的类名或序列化ID 为任务ID。

*   启动时SDK扫描代码中被 OpAsyncTask 注解的类（任务处理类），生成本地注册表。
    

*   生产消息时，perform方法会自动带上当前任务处理类的类名，存入Redis。
    

*   poller 获取任务时根据 任务中的处理类类名，分发给对应的处理类来处理。
    

  

### [](https://souche.yuque.com/arch/optask/kgwl91#56aaaa93)轮询时间间隔设置

平均间隔时间定为15秒每次，

为了防止机器数量增加导致访问Redis过于频繁, 所以根据机器的数量来动态调整轮询的间隔时间, 并且加入随机因子让每次间隔时间都是随机变化的，保证各台机器可以错开访问，防止类似雪崩之类的系统故障.

设avgInterval为15秒, random是随机变量, 取值范围为\[0, 1\], size是客户端机器数
每台机器实际的轮询时间间隔为： avgInterval * (1/2 + random) * size 
整个机器集群来讲，平均轮询间隔时间为15秒.

  

### [](https://souche.yuque.com/arch/optask/kgwl91#959c0c09)Redis数据结构

// 元信息
\[set \] clients (client集合，每个元素有过期时间，通过客户端的心跳请求维护在线状态)
\[hash\] {client-id}:info  (一个客户端一个hash, 表示客户端信息，key: client-id, field: hostname,started\_at,worker\_num等)
\[set \] index:bizIds (用于业务除重,过期时间1天)
\[key \] lock:timeout.check (poller检查任务超时所用的锁)
\[key \] lock:depend.wait (poller检查依赖任务所用的锁)

// 任务状态队列
\[list\] ready (就绪的任务)
\[hash\] working (正在执行中的任务, hash的field代表任务ID, value表示任务数据(json字符串的形式), 任务数据中包含机器信息)
\[list\] success:{date} (处理完成的任务，每天生成一个list, value是任务信息，保存180天)
\[list\] dead (死亡任务: value是任务信息，过期时间180天)
\[zset\] retry (重试任务)

// 延迟队列相关
\[zset\] delay (延迟任务)

// 等待队列相关
\[list\] depend.wait (等待被依赖任务完成的任务)
\[set \] index:depend.finish.parent: (已经完成的"被依赖的"的任务的索引, value是bizId，过期3天)

### [](https://souche.yuque.com/arch/optask/kgwl91#d41d8cd9)  

### [](https://souche.yuque.com/arch/optask/kgwl91#150cb2a6)报警点

*   任务堆积报警（当前任务堆积数 \> N次报警）

  

### [](https://souche.yuque.com/arch/optask/kgwl91#f2dcbe3a)仪表盘 ![](./Optimus-AsyncTask 架构文档 · 杭州大搜车汽车服务有限公司_files/1546012167721-5c751f07-80de-4485-b336-8175f2a01c65.png) 

[](https://souche.yuque.com/arch/optask/kgwl91#1aecdc85)里程碑
-----------------------------------------------------------

1.0 ( < 2019.2.28)

*   支持普通异步队列
    

*   支持延迟队列
    

*   支持执行依赖队列
    

*   提供仪表盘
    

*   接入技术运营大盘
    

*   接入报警中心
  